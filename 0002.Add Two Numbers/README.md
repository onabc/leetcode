## 两数相加

### 描述：

给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

### 示例：

1. 示例一：

   ```
   输入：l1 = [2,4,3], l2 = [5,6,4]
   输出：[7,0,8]
   解释：342 + 465 = 807.
   ```

2. 示例二：

   ```
   输入：l1 = [0], l2 = [0]
   输出：[0]
   ```

3. 示例三：

   ```
   输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
   输出：[8,9,9,9,0,0,0,1]
   ```

### 思路

首先每一位相加肯定会产生进位，我们用 carry 表示。进位最大会是 1 ，因为最大的情况是无非是 9 + 9 + 1 = 19
，也就是两个最大的数相加，再加进位，这样最大是 19 ，不会产生进位 2 。下边是伪代码。

1. 初始化一个节点的头，dummy head ，但是这个头不存储数字。并且将 curr 指向它。
2. 初始化进位 carry 为 0 。
3. 初始化 p 和 q 分别为给定的两个链表 l1 和 l2 的头，也就是个位。
4. 循环，直到 l1 和 l2 全部到达 null 。
    + 设置 x 为 p 节点的值，如果 p 已经到达了 null，设置 x 为 0 。

    + 设置 y 为 q 节点的值，如果 q 已经到达了 null，设置 y 为 0 。

    + 设置 sum = x + y + carry 。

    + 更新 carry = sum / 10 。

    + 创建一个值为 sum mod 10 的节点，并将 curr 的 next 指向它，同时 curr 指向变为当前的新节点。
      向前移动 p 和 q 。

5. 判断 carry 是否等于 1 ，如果等于 1 ，在链表末尾增加一个为 1 的节点。
6. 返回 dummy head 的 next ，也就是个位数开始的地方。

初始化的节点 dummy head 没有存储值，最后返回 dummy head 的 next 。这样的好处是不用单独对 head 进行判断改变值。也就是如果一开始的
head 就是代表个位数，那么开始初始化的时候并不知道它的值是多少，所以还需要在进入循环前单独对它进行值的更正，不能像现在一样只用一个循环简洁。
